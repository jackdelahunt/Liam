# io
extern fn print[T](t: T): void;
extern fn println[T](t: T): void;
extern fn read(path: str): String;

# memory
extern fn set_allocator(name: str, size: u64): void;
extern fn alloc[T](t: T): ^T;
extern fn destroy[T](t: ^T): void;
extern fn hashcode[T](t: ^T): u64;

# core
extern fn panic(string: str): void;
extern fn len(string: str): u64;
extern fn substr(s: str, start: u64, length: u64): str;
extern fn char_at(s: str, index: u64): str;
extern fn is_digit(s: str): bool;
extern fn assert_true(condition: bool): void;

# String
extern struct String {
    string: str
}
extern fn make_string(from: str): String;
extern fn string_append(s: ^String, x: ^String): void;
extern fn string_append_str(s: ^String, s: str): void;

# collections
struct Tuple[O, T] {
    one: O,
    two: T
}

extern struct Array[T] {
    length: u64,
    capacity: u64,
    data: ^T
}

extern struct Map[K, V] {

}

extern fn make_array[T](): Array[T];
extern fn array_append[T](array: ^Array[T], t: T): void;
extern fn array_index[T](array: ^Array[T], index: u64): T;
extern fn array_insert[T](array: ^Array[T], index: u64, t: T): void;
extern fn array_remove[T](array: ^Array[T], index: u64): void;
extern fn array_free[T](array: ^Array[T]): void;

extern fn make_map[K, V](): Map[K, V];
extern fn map_insert[K, V](map: ^Map[K, V], k: K, v: V): void;
extern fn map_get[K, V](map: ^Map[K, V], k: K): V;
